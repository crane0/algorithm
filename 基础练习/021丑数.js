/* 
  三指针
  丑数的排列 1,2,3,4,5,6,8,10.... 
  其中一个特点，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，
  那么如何得到所有丑数呢？
  现在假设有3个数组，分别是： 
    A：[ 1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2...... ]
    B：[ 1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3...... ]
    C：[ 1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5...... ]
  那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的。
  这就转换成了三个有序数组的无重复元素合并的问题了。
  而这三个数组就刚好是 [1,2,3,4,5,6,8,10....] 乘以2,3,5得到的。

  合并有序数组的方法:
  每个数组都对应一个指针，比较这些指针所指的数哪个最小，就将这个数放到结果数组中，该指针向后挪一位，其他数组指针不变。

  本题中，要求丑数数组 ugly 中的第n项，而目前只知道 ugly[0]=1，所以此时三个有序数组分别就只有一个元素：
    A：[ 1*2 ]
    B：[ 1*3 ]
    C：[ 1*5 ]
  假设三个数组的指针分别是 i,j,k，此时均是指向第一个元素，
  然后比较A[i]，B[j]和C[k]，得到的最小的数A[i]，就是ugly[1]，此时ugly就变成 [1,2] 了，对应的ABC数组就分别变成了：
    A：[ 1*2, 2*2 ]
    B：[ 1*3, 2*3 ]
    C：[ 1*5, 2*5 ]
  此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即'2*2'，而j和k依然分别指向B[0]和C[0]，
  然后进行下一轮合并，就是A[1]和B[0]和C[0]比较，最小值作为 ugly[2]..... 如此循环n次，就可以得到ugly[n]了。

  此外，注意到ABC三个数组实际上就是 ugly*2，ugly*3 和 ugly*5 的结果，
  所以每次只需要比较 A[i]=ugly[i]*2，B[j]=ugly[j]*3 和 C[k]=ugly[k]*5 的大小即可。
  谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。
*/

function nthUglyNumber(n) {
  if (!n) return 0
  let ugly = []
  ugly[0] = 1
  let i = 0, j = 0, k = 0;
  // 注意从 1 开始
  for (let index = 1; index < n; index++) {
    let temp = Math.min(ugly[i]*2, ugly[j]*3, ugly[k]*5)
    if(temp == ugly[i]*2) i++;
    if(temp == ugly[j]*3) j++;
    if(temp == ugly[k]*5) k++;
    ugly[index] = temp;
  }
  return ugly[n-1]
}

console.log(nthUglyNumber(10))